/*
**	E X T R A C T
**
**	Copyright 1991-1996 University Corporation for Atmospheric Research
**			All Rights Reserved
**
**	Title		Extract Binary Fields
**	Program		cmsundump
**	Project		CMS to UNIX Conversion
**	Author		John Sloan
**	Email		jsloan@ncar.ucar.edu
**	Date		Tue Sep 10 14:09:14 MDT 1991
**	Organization	NCAR, P.O. Box 3000, Boulder CO 80307
**
**	Abstract
**
**	IMPORTANT! This code is intended to work only on network data
**	types, i.e. those data types returned by htonl() and htons().
**	Any other uses depends on the byte-order of the host machine
**	and is hence completely unreliable and non-portable. When you
**	see insert16/32 or extract16/32 used in libtools and/or libipc,
**	it should be only in conjunction with hton[ls] and ntoh[ls].
**	The 64-bit functions will only work on architectures which
**	actually have a 64-bit integer data type (e.g. long on DEC
**	Alpha, NEC SX-4). The signed version of the routines are really
**	quite bogus, as the network data types are unsigned. In any case,
**	twos-complement is assumed.
**
**	Note that although the "l" in "htonl" and "ntohl" means "long",
**	the intent is that it supports a 32-bit data type, while
**	"htons" and "ntohs" ("short") supports a 16-bit data type. The
**	implementations on both the DEC Alpha and the NEC SX-4, where
**	sizeof(long)==64, support this. For example, on the DEC Alpha,
**	"htonl" is declared "int" and takes an "int", which on the
**	Alpha is 32-bits, as an argument.
**
**	The 4.6 release of this code, from 1994 June 03, has been
**	regression tested on CRAY Y-MP, DEC ALPHA, IBM RS6K, and
**	SMI SPARC.
**
**	See the header file libtbase.h, which is generated by the
**	program genbasetypes.c as part of the libtools installation,
**	for more information about the underlying data types such as
**	libt_unsigned32.
*/

static char copyright[]="Copyright 1991-1996 University Corporation for Atmospheric Research - All Rights Reserved";
static char sccsid[]="@(#)extract.c	4.20 96/07/08 jsloan@ncar.ucar.edu";

#include "libtools.h"
#include <stdio.h>
#include "libtvalues.h"
#include "libtstrings.h"
#include "libtbase.h"
#include "extract.h"

#define HIBIT8	((char)(1<<(BITS(char)-1)))

#ifdef LIBT_SIGNED64
#define SIZEOFNET64	(64/BITSPERBYTE)
#define	SIZE64		(sizeof(libt_signed64)<SIZEOFNET64?sizeof(libt_signed64):SIZEOFNET64)
#endif /* LIBT_SIGNED64 */

#ifdef LIBT_UNSIGNED64
libt_unsigned64
extract64(char *nll)
	{
	libt_unsigned64 hll;
	int len;

	len=SIZE64;
	hll=(libt_unsigned64)0;
	(void)memcpy((char *)&hll+sizeof(hll)-len,nll+SIZEOFNET64-len,len);
	return(hll);
	}

char *
insert64(libt_unsigned64 hll, char *nll)
	{
	int len;

	len=SIZE64;
	(void)memset(nll,(unsigned char)0,SIZEOFNET64);
	(void)memcpy(nll+SIZEOFNET64-len,(char *)&hll+sizeof(hll)-len,len);
	return(nll);
	}
#endif /* LIBT_UNSIGNED64 */

#ifdef LIBT_SIGNED64
libt_signed64
extracts64(char *nll)
	{
	libt_signed64 hll;
	int len;

	len=SIZE64;
	hll=((nll[0]&HIBIT8)?(~(libt_signed64)0):(libt_signed64)0);
	(void)memcpy((char *)&hll+sizeof(hll)-len,nll+SIZEOFNET64-len,len);
	return(hll);
	}

char *
inserts64(libt_signed64 hll, char *nll)
	{
	int len;

	len=SIZE64;
	(void)memset(nll,(hll<0)?(~0):0,SIZEOFNET64);
	(void)memcpy(nll+SIZEOFNET64-len,(char *)&hll+sizeof(hll)-len,len);
	return(nll);
	}
#endif /* LIBT_SIGNED64 */

#ifdef LIBT_SIGNED32
#define SIZEOFNET32	(32/BITSPERBYTE)
#define	SIZE32	(sizeof(libt_signed32)<SIZEOFNET32?sizeof(libt_signed32):SIZEOFNET32)
#endif /* LIBT_SIGNED32 */

#ifdef LIBT_UNSIGNED32
libt_unsigned32
extract32(char *nl)
	{
	libt_unsigned32 hl;
	int len;

	len=SIZE32;
	hl=(libt_unsigned32)0;
	(void)memcpy((char *)&hl+sizeof(hl)-len,nl+SIZEOFNET32-len,len);
	return(hl);
	}

char *
insert32(libt_unsigned32 hl, char *nl)
	{
	int len;

	len=SIZE32;
	(void)memset(nl,0,SIZEOFNET32);
	(void)memcpy(nl+SIZEOFNET32-len,(char *)&hl+sizeof(hl)-len,len);
	return(nl);
	}
#endif /* LIBT_UNSIGNED32 */

#ifdef LIBT_SIGNED32
libt_signed32
extracts32(char *nl)
	{
	libt_signed32 hl;
	int len;

	len=SIZE32;
	hl=((nl[0]&HIBIT8)?(~(libt_signed32)0):(libt_signed32)0);
	(void)memcpy((char *)&hl+sizeof(hl)-len,nl+SIZEOFNET32-len,len);
	return(hl);
	}

char *
inserts32(libt_signed32 hl, char *nl)
	{
	int len;

	len=SIZE32;
	(void)memset(nl,(hl<0)?(~0):0,SIZEOFNET32);
	(void)memcpy(nl+SIZEOFNET32-len,(char *)&hl+sizeof(hl)-len,len);
	return(nl);
	}
#endif /* LIBT_SIGNED32 */

#ifdef LIBT_SIGNED16
#define SIZEOFNET16	(16/BITSPERBYTE)
#define	SIZE16	(sizeof(libt_signed16)<SIZEOFNET16?sizeof(libt_signed16):SIZEOFNET16)
#endif /* LIBT_SIGNED16 */

#ifdef LIBT_UNSIGNED16
libt_unsigned16
extract16(char *ns)
	{
	libt_unsigned16 hs;
	int len;

	len=SIZE16;
	hs=(libt_unsigned16)0;
	(void)memcpy((char *)&hs+sizeof(hs)-len,ns+SIZEOFNET16-len,len);
	return(hs);
	}

char *
insert16(libt_unsigned16 hs, char *ns)
	{
	int len;

	len=SIZE16;
	(void)memset(ns,0,SIZEOFNET16);
	(void)memcpy(ns+SIZEOFNET16-len,(char *)&hs+sizeof(hs)-len,len);
	return(ns);
	}
#endif /* LIBT_UNSIGNED16 */

#ifdef LIBT_SIGNED16
libt_signed16
extracts16(char *ns)
	{
	libt_signed16 hs;
	int len;

	len=SIZE16;
	hs=((ns[0]&HIBIT8)?(~(libt_signed16)0):(libt_signed16)0);
	(void)memcpy((char *)&hs+sizeof(hs)-len,ns+SIZEOFNET16-len,len);
	return(hs);
	}

char *
inserts16(libt_signed16 hs, char *ns)
	{
	int len;

	len=SIZE16;
	(void)memset(ns,(hs<0)?(~0):0,SIZEOFNET16);
	(void)memcpy(ns+SIZEOFNET16-len,(char *)&hs+sizeof(hs)-len,len);
	return(ns);
	}
#endif /* LIBT_SIGNED16 */
